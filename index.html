<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Tools (完全ローカル版)</title>

    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <!-- PDF Processing Libraries -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- PDF.js for rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');

        body {
            font-family: 'Noto Sans JP', sans-serif;
        }
    </style>
</head>

<body class="bg-slate-50 min-h-screen flex items-center justify-center relative pb-20">
    <div id="root" class="w-full max-w-md p-4"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { PDFDocument, rgb, degrees } = PDFLib;

        // PDF.js Worker Setup
        // Using a reliable CDN version
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const Icon = ({ name, size = 24, className }) => {
            useEffect(() => { lucide.createIcons(); }, [name]);
            return <i data-lucide={name} width={size} height={size} className={className}></i>;
        };

        const TOOLS = [
            { id: 'split', name: 'PDF 分割', desc: 'ページを選択して分割・抽出', icon: 'scissors' },
            { id: 'merge', name: 'PDF 結合', desc: '複数のPDFを1つに結合', icon: 'layers' },
            { id: 'reorder', name: '並び替え', desc: 'ドラッグ&ドロップで並び替え', icon: 'arrow-left-right' },
            { id: 'pdf2img', name: 'PDF→画像', desc: 'PDFを画像に変換', icon: 'image' },
            { id: 'img2pdf', name: '画像→PDF', desc: '画像をPDFに変換', icon: 'file-image' },
            { id: 'protect', name: '保護', desc: 'パスワードを設定', icon: 'lock' },
            { id: 'nup', name: '4枚集約', desc: '4ページを1ページに集約', icon: 'layout-grid' },
        ];

        // --- Helper Functions ---
        const readFileAsArrayBuffer = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        };

        const renderPageToImage = async (file, pageIndex, scale = 0.5) => {
            try {
                const arrayBuffer = await readFileAsArrayBuffer(file);
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                if (pageIndex >= pdf.numPages) return null;
                const page = await pdf.getPage(pageIndex + 1);
                const viewport = page.getViewport({ scale });

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: context, viewport: viewport }).promise;
                return canvas.toDataURL('image/jpeg', 0.8);
            } catch (e) {
                console.error("Render error", e);
                return null;
            }
        };

        const loadPDFPages = async (file) => {
            const arrayBuffer = await readFileAsArrayBuffer(file);
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            const pages = [];
            for (let i = 0; i < pdf.numPages; i++) {
                // Generate thumbnail
                const image = await renderPageToImage(file, i, 0.2); // Low res for thumbnail
                pages.push({ index: i + 1, image, selected: false });
            }
            return pages;
        }

        const App = () => {
            const [activeToolId, setActiveToolId] = useState('split');
            const [files, setFiles] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [statusMsg, setStatusMsg] = useState('');

            // Tool specific states
            const [splitMode, setSplitMode] = useState('all'); // 'all', 'custom'
            const [splitRange, setSplitRange] = useState('');
            const [reorderList, setReorderList] = useState([]); // Array of {index, image}
            const [password, setPassword] = useState('');

            // Preview State
            const [previewImage, setPreviewImage] = useState(null);

            const fileInputRef = useRef(null);
            const gridRef = useRef(null);
            const activeTool = TOOLS.find(t => t.id === activeToolId);

            // Calculate active files/thumbnails
            useEffect(() => {
                const loadThumbnails = async () => {
                    if (files.length > 0 && files[0].type === 'application/pdf') {
                        if (activeToolId === 'reorder' || activeToolId === 'split') {
                            setIsLoading(true);
                            if (activeToolId === 'split') setStatusMsg('ページ読み込み中...');

                            try {
                                const pages = await loadPDFPages(files[0]);
                                setReorderList(pages);
                            } catch (e) {
                                console.error(e);
                                alert("PDFの読み込みに失敗しました");
                            } finally {
                                setIsLoading(false);
                                setStatusMsg('');
                            }
                        }
                    } else if (activeToolId !== 'reorder') {
                        setReorderList([]);
                    }
                };
                loadThumbnails();
            }, [files, activeToolId]);

            // Preview Loader
            useEffect(() => {
                const loadPreview = async () => {
                    if (files.length > 0) {
                        try {
                            if (files[0].type === 'application/pdf') {
                                const img = await renderPageToImage(files[0], 0, 0.5); // Preview first page
                                setPreviewImage(img);
                            } else if (files[0].type.startsWith('image/')) {
                                const reader = new FileReader();
                                reader.onload = (e) => setPreviewImage(e.target.result);
                                reader.readAsDataURL(files[0]);
                            } else {
                                setPreviewImage(null);
                            }
                        } catch (e) {
                            console.error("Preview error:", e);
                            setPreviewImage(null);
                        }
                    } else {
                        setPreviewImage(null);
                    }
                };
                loadPreview();
            }, [files]);


            // Sortable init for Reorder
            useEffect(() => {
                let sortable = null;
                if (gridRef.current && reorderList.length > 0 && activeToolId === 'reorder') {
                    sortable = new Sortable(gridRef.current, {
                        animation: 150,
                        ghostClass: 'bg-indigo-100',
                        onEnd: (evt) => {
                            if (evt.oldIndex === evt.newIndex) return;
                            setReorderList(prev => {
                                const newItems = [...prev];
                                const [moved] = newItems.splice(evt.oldIndex, 1);
                                newItems.splice(evt.newIndex, 0, moved);
                                return newItems;
                            });
                        }
                    });
                }
                return () => sortable && sortable.destroy();
            }, [reorderList.length, activeToolId]);

            const handleFileChange = (e) => {
                if (e.target.files && e.target.files.length > 0) {
                    setFiles(Array.from(e.target.files));
                }
            };

            // Sync Split Selection to Range Text
            const togglePageSelection = (idx) => {
                setReorderList(prev => {
                    const newItems = [...prev];
                    newItems[idx].selected = !newItems[idx].selected;

                    // Update text range
                    const selectedIndices = newItems.filter(p => p.selected).map(p => p.index);
                    setSplitRange(selectedIndices.join(', '));

                    return newItems;
                });
                setSplitMode('custom');
            };

            const executeTool = async () => {
                if (files.length === 0) {
                    alert("ファイルを選択してください。");
                    return;
                }
                setIsLoading(true);
                setStatusMsg('処理中...');

                try {
                    if (activeToolId === 'split') await processSplit();
                    if (activeToolId === 'merge') await processMerge();
                    if (activeToolId === 'reorder') await processReorder();
                    if (activeToolId === 'pdf2img') await processPdfToImg();
                    if (activeToolId === 'img2pdf') await processImgToPdf();
                    if (activeToolId === 'protect') await processProtect();
                    if (activeToolId === 'nup') await processNup();

                    setStatusMsg('完了しました！');
                    setTimeout(() => setStatusMsg(''), 2000);
                } catch (e) {
                    console.error(e);
                    alert("エラーが発生しました: " + e.message);
                } finally {
                    setIsLoading(false);
                }
            };

            // --- Logic Implementations ---

            const processSplit = async () => {
                const pdfBytes = await readFileAsArrayBuffer(files[0]);
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const zip = new JSZip();

                if (splitMode === 'all') {
                    for (let i = 0; i < pdfDoc.getPageCount(); i++) {
                        const newPdf = await PDFDocument.create();
                        const [copiedPage] = await newPdf.copyPages(pdfDoc, [i]);
                        newPdf.addPage(copiedPage);
                        const pdfBytes = await newPdf.save();
                        zip.file(`page_${i + 1}.pdf`, pdfBytes);
                    }
                } else {
                    // Custom Logic for 'custom' (Supports text input or visual selection)
                    const ranges = splitRange.split(',').map(s => s.trim());
                    for (let range of ranges) {
                        if (!range) continue;
                        const newPdf = await PDFDocument.create();
                        // Support "1-3" or "5"
                        let pagesToAdd = [];
                        if (range.includes('-')) {
                            const [start, end] = range.split('-').map(n => parseInt(n));
                            for (let k = start; k <= end; k++) pagesToAdd.push(k - 1);
                        } else {
                            pagesToAdd.push(parseInt(range) - 1);
                        }

                        const copiedPages = await newPdf.copyPages(pdfDoc, pagesToAdd.filter(idx => idx >= 0 && idx < pdfDoc.getPageCount()));
                        copiedPages.forEach(p => newPdf.addPage(p));

                        if (copiedPages.length > 0) {
                            const bytes = await newPdf.save();
                            zip.file(`split_${range}.pdf`, bytes);
                        }
                    }
                }

                const content = await zip.generateAsync({ type: "blob" });
                download(content, "split_files.zip", "application/zip");
            };

            const processMerge = async () => {
                const mergedPdf = await PDFDocument.create();
                for (const file of files) {
                    const bytes = await readFileAsArrayBuffer(file);
                    const pdf = await PDFDocument.load(bytes);
                    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
                    copiedPages.forEach((page) => mergedPdf.addPage(page));
                }
                const pdfBytes = await mergedPdf.save();
                download(pdfBytes, "merged.pdf", "application/pdf");
            };

            const processReorder = async () => {
                const pdfBytes = await readFileAsArrayBuffer(files[0]);
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const newPdf = await PDFDocument.create();

                // reorderList has {index: 1...} which maps to 0-index
                const indices = reorderList.map(item => item.index - 1);

                const copiedPages = await newPdf.copyPages(pdfDoc, indices);
                copiedPages.forEach(p => newPdf.addPage(p));

                const outBytes = await newPdf.save();
                download(outBytes, "reordered.pdf", "application/pdf");
            };

            const processPdfToImg = async () => {
                const zip = new JSZip();
                const arrayBuffer = await readFileAsArrayBuffer(files[0]);
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

                for (let i = 0; i < pdf.numPages; i++) {
                    setStatusMsg(`変換中... (${i + 1}/${pdf.numPages})`);
                    const page = await pdf.getPage(i + 1);
                    const viewport = page.getViewport({ scale: 2.0 }); // High quality
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport: viewport }).promise;

                    const imgData = canvas.toDataURL('image/jpeg', 0.9);
                    const base64Data = imgData.replace(/^data:image\/(png|jpeg);base64,/, "");
                    zip.file(`page_${i + 1}.jpg`, base64Data, { base64: true });
                }

                const content = await zip.generateAsync({ type: "blob" });
                download(content, "pdf_images.zip", "application/zip");
            };

            const processImgToPdf = async () => {
                const pdfDoc = await PDFDocument.create();
                for (const file of files) {
                    const imgBytes = await readFileAsArrayBuffer(file);
                    let image;
                    if (file.type === 'image/jpeg') image = await pdfDoc.embedJpg(imgBytes);
                    else if (file.type === 'image/png') image = await pdfDoc.embedPng(imgBytes);
                    else continue;

                    const page = pdfDoc.addPage([image.width, image.height]);
                    page.drawImage(image, { x: 0, y: 0, width: image.width, height: image.height });
                }
                const pdfBytes = await pdfDoc.save();
                download(pdfBytes, "images.pdf", "application/pdf");
            };

            const processProtect = async () => {
                const pdfBytes = await readFileAsArrayBuffer(files[0]);
                const pdfDoc = await PDFDocument.load(pdfBytes);
                pdfDoc.encrypt({ userPassword: password, ownerPassword: password });
                const outBytes = await pdfDoc.save();
                download(outBytes, "protected.pdf", "application/pdf");
            };

            const processNup = async () => {
                const pdfBytes = await readFileAsArrayBuffer(files[0]);
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const newPdf = await PDFDocument.create();
                const pages = pdfDoc.getPages();
                const count = pages.length;

                for (let i = 0; i < count; i += 4) {
                    const dims = pages[0].getSize();
                    const newPage = newPdf.addPage([dims.width, dims.height]);

                    const chunk = [i, i + 1, i + 2, i + 3].filter(idx => idx < count);
                    const embeddedPages = await newPdf.embedPages(pdfDoc, chunk);

                    const pos = [
                        { x: 0, y: dims.height / 2 },
                        { x: dims.width / 2, y: dims.height / 2 },
                        { x: 0, y: 0 },
                        { x: dims.width / 2, y: 0 }
                    ];

                    embeddedPages.forEach((emb, idx) => {
                        const p = pos[idx];
                        newPage.drawPage(emb, {
                            x: p.x,
                            y: p.y,
                            width: dims.width / 2,
                            height: dims.height / 2,
                        });
                    });
                }
                const outBytes = await newPdf.save();
                download(outBytes, "nup_4in1.pdf", "application/pdf");
            };

            // --- Render ---
            useEffect(() => {
                setFiles([]);
                setReorderList([]);
                setPassword('');
                setStatusMsg('');
                setPreviewImage(null);
                setSplitRange('');
                setSplitMode('all');
            }, [activeToolId]);

            useEffect(() => { lucide.createIcons(); });

            return (
                <div className="relative">
                    <div className="bg-white rounded-3xl p-8 shadow-2xl relative z-10 mx-auto transform transition-all hover:scale-[1.01] mb-20 animate-fade-in">

                        {/* Header */}
                        <div className="text-center mb-8">
                            <h1 className="text-2xl font-bold text-slate-800 mb-2">{activeTool.name}</h1>
                            <p className="text-sm text-slate-500 font-medium">{activeTool.desc}</p>
                        </div>

                        {/* Upload */}
                        <div className={`border-2 border-dashed rounded-2xl bg-slate-50 hover:bg-slate-100 transition-colors cursor-pointer p-8 mb-8 flex flex-col items-center justify-center group ${files.length > 0 ? 'border-indigo-500 bg-indigo-50' : 'border-slate-200'}`}
                            onClick={() => fileInputRef.current.click()}>
                            <input type="file" ref={fileInputRef} className="hidden"
                                multiple={activeToolId === 'merge' || activeToolId === 'img2pdf'}
                                accept={activeToolId === 'img2pdf' ? "image/*" : "application/pdf"}
                                onChange={handleFileChange} />
                            <div className="bg-white p-4 rounded-full shadow-sm mb-3 group-hover:scale-110 transition-transform">
                                <Icon name={files.length > 0 ? "check" : "cloud-upload"} className={files.length > 0 ? "text-green-500" : "text-indigo-500"} size={32} />
                            </div>
                            <p className="text-slate-600 font-medium">{files.length > 0 ? `${files.length} ファイル選択中` : "ファイルを選択 or ドロップ"}</p>
                        </div>

                        {/* Preview Area (General) */}
                        {previewImage && activeToolId !== 'split' && activeToolId !== 'reorder' && (
                            <div className="mb-8 border rounded-xl overflow-hidden bg-slate-100 flex justify-center p-4">
                                <div className="text-center">
                                    <p className="text-xs text-slate-500 mb-2 font-bold">プレビュー (1ページ目)</p>
                                    <img src={previewImage} alt="Preview" className="max-h-64 object-contain shadow-md mx-auto" />
                                </div>
                            </div>
                        )}

                        {/* Options */}
                        <div className="space-y-4 mb-8">
                            {/* Split Visual UI */}
                            {activeToolId === 'split' && (
                                <>
                                    <div className="flex gap-4">
                                        <label className={`flex-1 flex items-center p-3 rounded-xl border-2 cursor-pointer ${splitMode === 'all' ? 'border-indigo-500 bg-indigo-50' : 'border-slate-100'}`}>
                                            <input type="radio" className="mr-2" checked={splitMode === 'all'} onChange={() => setSplitMode('all')} /> 全ページ
                                        </label>
                                        <label className={`flex-1 flex items-center p-3 rounded-xl border-2 cursor-pointer ${splitMode === 'custom' ? 'border-indigo-500 bg-indigo-50' : 'border-slate-100'}`}>
                                            <input type="radio" className="mr-2" checked={splitMode === 'custom'} onChange={() => setSplitMode('custom')} /> 抽出指定
                                        </label>
                                    </div>

                                    {/* Thumbnail Grid for Split */}
                                    {files.length > 0 && (
                                        <div className="mt-4">
                                            <p className="text-xs text-slate-500 mb-2">クリックして抽出するページを選択 (ピンク枠が対象)</p>
                                            <div className="grid grid-cols-3 md:grid-cols-4 gap-2 max-h-80 overflow-y-auto border p-2 rounded-lg">
                                                {reorderList.map((item, idx) => (
                                                    <div key={item.index}
                                                        onClick={() => togglePageSelection(idx)}
                                                        className={`relative p-1 rounded border-2 cursor-pointer transition-all ${item.selected ? 'border-pink-500 bg-pink-50 ring-2 ring-pink-200' : 'border-slate-200 hover:border-indigo-300'}`}>
                                                        <img src={item.image} className="w-full h-auto rounded" />
                                                        <div className="absolute top-1 left-1 bg-black/60 text-white text-[10px] px-1.5 py-0.5 rounded-full">{item.index}</div>
                                                        {item.selected && (
                                                            <div className="absolute top-1 right-1 bg-pink-500 text-white rounded-full p-0.5">
                                                                <Icon name="check" size={12} />
                                                            </div>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}

                                    {splitMode === 'custom' && (
                                        <div className="mt-2 text-xs text-slate-500">
                                            選択中: {splitRange || "なし"}
                                        </div>
                                    )}
                                </>
                            )}

                            {/* Reorder Visual UI */}
                            {activeToolId === 'reorder' && (
                                <div>
                                    <div className="flex items-center justify-between mb-2">
                                        <p className="text-sm font-bold text-slate-700">ドラッグして順番を変更</p>
                                        <button onClick={() => setReorderList([...reorderList].sort((a, b) => a.index - b.index))} className="text-xs text-indigo-500 underline">リセット</button>
                                    </div>
                                    <div ref={gridRef} className="grid grid-cols-3 md:grid-cols-4 gap-3 max-h-80 overflow-y-auto p-1">
                                        {reorderList.map((item) => (
                                            <div key={item.index} className="bg-slate-50 p-2 rounded-xl border-2 border-slate-200 cursor-grab active:cursor-grabbing hover:border-indigo-400 transition-colors relative shadow-sm group">
                                                <img src={item.image} className="w-full h-auto rounded pointer-events-none" />
                                                <div className="absolute top-2 left-2 bg-slate-800 text-white text-xs px-2 py-0.5 rounded-full shadow-md">{item.index}</div>
                                                <div className="absolute inset-0 bg-indigo-500/0 group-hover:bg-indigo-500/5 transition-colors rounded-xl"></div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {activeToolId === 'protect' && (
                                <input type="password" className="w-full p-3 rounded-lg border-2 border-slate-200" placeholder="パスワードを入力" value={password} onChange={(e) => setPassword(e.target.value)} />
                            )}
                        </div>

                        {/* Button */}
                        <button className={`w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 rounded-full shadow-lg transition-all flex items-center justify-center gap-2 ${isLoading ? 'opacity-70 cursor-wait' : ''}`}
                            onClick={executeTool} disabled={isLoading}>
                            {isLoading ? statusMsg : "実行してダウンロード"}
                            {!isLoading && <Icon name="arrow-right" size={20} />}
                        </button>
                    </div>

                    {/* Nav */}
                    <div className="fixed bottom-0 left-0 w-full bg-slate-900 text-white p-2 flex justify-around rounded-t-3xl shadow-2xl z-50">
                        {TOOLS.map(t => (
                            <div key={t.id} className={`flex flex-col items-center p-2 rounded-xl cursor-pointer ${activeToolId === t.id ? 'text-indigo-400 scale-105' : 'text-slate-500'}`} onClick={() => setActiveToolId(t.id)}>
                                <Icon name={t.icon} size={20} />
                                <span className="text-[10px] mt-1">{t.name.substring(0, 4)}</span>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>